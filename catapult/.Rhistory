m0<- km(~1+axe+butee, design=X, response=Y)
m0
m0<- km(~1+axe+butee, design=X, response=Y)
m0
km?
?km
m0
oEGO <- max_EI(model = m0, lower = rep(0, 4), upper = rep(1, 4))
newX <- oEGO$par
newy <- runExperimentMin(newX)
cat("Expected improvement was :", round(oEGO$value,2),
"\nActual improvement is:", round(min(Y) - newy,2),
"\n   (>0 means the new point is better, <0 means its worst)")
# The model can be updated with the new design point and observation
m <- update(m0, newX, newy)
m
oEGO <- EGO.nsteps(model = m0, fun = runExperimentMin, nsteps = 20,
lower = rep(0, 4), upper = rep(1, 4))
bestPoint <- which.min(oEGO$value)
cat("longest shot observed:",-round(oEGO$value[bestPoint],2),
"\ncorresponding input values:",round(oEGO$par[bestPoint,],2))
plot(oEGO$value)
sectionview(oEGO$lastmodel, center = oEGO$par[bestPoint, ])
plot(oEGO$value)
visualizeEGO(initDesign = X, initValues = Y,
EGOpoints = oEGO$par, EGOvalues = oEGO$val)
## look at the locations visited by the algorithm
visualizeEGO <- function(initDesign, initValues, EGOpoints, EGOvalues){
bestIndex <- which.min(EGOvalues)
y <- c(initValues, EGOvalues, EGOvalues[bestIndex])
X <- rbind(initDesign, EGOpoints, EGOpoints[bestIndex, ])
ninit <- nrow(initDesign)
nsteps <- nrow(EGOpoints)
pairs(cbind(y, X),
col = c(rep("black", ninit), rep("blue", nsteps), "red"),
pch = c(rep(1, ninit + nsteps), 19))
}
visualizeEGO(initDesign = X, initValues = Y,
EGOpoints = oEGO$par, EGOvalues = oEGO$val)
plot(oEGO$value)
plot(Y,oEGO$value)
plot(c(Y,oEGO$value))
lines(rep(length(Y)+.5,2),range(Y,oEGO$value))
lines(rep(length(Y)+.5,2),range(Y,oEGO$value),lty=2)
plot(c(Y,oEGO$value))
lines(rep(length(Y)+.5,2),range(Y,oEGO$value),lty=2)
?min
runApp()
source('~/EMSE/OQUAIDO/Formations/2016_06_FontenayAuxRoses/catapult/TPsolutions.R', echo=TRUE)
plot(c(Y,oEGO$value))
lines(rep(length(Y)+.5,2),range(Y,oEGO$value),lty=2)
pairs(X)
plot(c(Y,oEGO$value))
lines(rep(length(Y)+.5,2),range(Y,oEGO$value),lty=2)
cummin
cummin(Y)
lines(length(Y)+1:length(oEGO$value),cummin(oEGO$value),col='red')
plot(c(Y,oEGO$value),main="convergence")
lines(rep(length(Y)+.5,2),range(Y,oEGO$value),lty=2,col="gray")
lines(length(Y)+1:length(oEGO$value),cummin(oEGO$value),col="red",lwd=2)
lines(rep(length(Y),2),range(Y,oEGO$value),lty=2,col="gray")
plot(c(Y,oEGO$value),main="convergence")
lines(rep(length(Y),2),range(Y,oEGO$value),lty=2,col="gray")
lines(length(Y)+0:length(oEGO$value),c(min(Y),cummin(oEGO$value)),col="red",lwd=2)
plot(c(Y,oEGO$value),main="convergence",xlab="evaluation number",ylab="Y values")
lines(rep(length(Y),2),range(Y,oEGO$value),lty=2,col="gray")
lines(length(Y)+0:length(oEGO$value),c(min(Y),cummin(oEGO$value)),col="red",lwd=2)
library(shiny)
runApp() #execute l'appli en local, les fichiers ui.R et server.R doivent se trouver dans le repertoire de travail
runUrl("https://sites.google.com/site/nicolasdurrandehomepage/catapult.zip")
runApp()
library(DiceDesign)
X0 <- lhsDesign(n = 16, dimension = 4)$design
Xopt <- maximinESE_LHS(X0, it=10)
X <- Xopt$design
colnames(X) <- c("axe", "butee", "ressort1", "ressort2")
pairs(X)
round(X,2)
runApp()
Y <- runExperiment(X[1,])
par(mfrow=c(2,2)) # split the plotting area in 4
plot(X[,1],Y)
Y <- apply(X, 1, runExperiment)
Y <- Y[1,]
par(mfrow=c(2,2)) # split the plotting area in 4
plot(X[,1],Y)
plot(X[,2],Y)
plot(X[,3],Y)
plot(X[,4],Y)
par(mfrow=c(1,1))
library(rgl)
plot3d(x = X[,1], y = X[,2], z = Y)
pairs(cbind(Y, X))
?with
par(mfrow = c(2,2)) # split the plotting area in 4
with(X,
plot(axe, Y)
plot(butee, Y)
plot(ressort, Y)
plot(ressort2, Y))
?with
par(mfrow = c(2,2)) # split the plotting area in 4
with(X, {
plot(axe, Y)
plot(butee, Y)
plot(ressort1, Y)
plot(ressort2, Y)} )
par(mfrow=c(1,1))
str(X)
XY <- data.frame(x1=X[,1],x2=X[,2],x3=X[,3],x4 = X[,4],y=Y)
pairs(XY)
XY <- data.frame(y=Y, x1=X[,1],x2=X[,2],x3=X[,3],x4 = X[,4])
pairs(XY)
par(mfrow = c(2,2)) # split the plotting area in 4
with(XY, {
plot(axe, Y)
plot(butee, Y)
plot(ressort1, Y)
plot(ressort2, Y)} )
with(XY, {
plot(x1, Y)
plot(x2, Y)
plot(x3, Y)
plot(x4, Y)} )
par(mfrow=c(1,1))
XY <- cbind(Y = Y, X)
pairs(XY)
with(XY, {
plot(axe, Y)
plot(butee, Y)
plot(ressort1, Y)
plot(ressort2, Y)} )
par(mfrow=c(1,1))
XY <- data.frame(y=Y, x1=X[,1], x2=X[,2], x3=X[,3], x4 = X[,4])
pairs(XY)
XY <- cbind(Y = Y, X)
pairs(XY)
par(mfrow = c(2,2)) # split the plotting area in 4
with(XY, {
plot(axe, Y)
plot(butee, Y)
plot(ressort1, Y)
plot(ressort2, Y)} )
str(XY)
XY <- data.frame(Y = Y, X)
str(XY)
XY <- data.frame(Y = Y, X)
pairs(XY)
par(mfrow = c(2,2)) # split the plotting area in 4
with(XY, {
plot(axe, Y)
plot(butee, Y)
plot(ressort1, Y)
plot(ressort2, Y)} )
par(mfrow=c(1,1))
plot(X[,1], Y)
plot(X$butee, Y)
plot(XY[,2], Y)
plot(XY$butee, Y)
par(mfrow = c(2,2)) # split the plotting area in 4
plot(XY$butee, Y)
with(XY, {
plot(axe, Y)
plot(butee, Y)
plot(ressort1, Y)
plot(ressort2, Y)} )
par(mfrow=c(1,1))
par(mfrow=c(1,1))
par(mfrow = c(2,2)) # split the plotting area in 4
plot(XY$butee, Y)
with(XY, {
plot(axe, Y)
plot(butee, Y)
plot(ressort1, Y)
plot(ressort2, Y)} )
par(mfrow=c(1,1))
par(mfrow = c(2,2)) # split the plotting area in 4
with(XY, {
plot(axe, Y)
plot(butee, Y)
plot(ressort1, Y)
plot(ressort2, Y)} )
par(mfrow=c(1,1))
library(rgl)
plot3d(x = X[,1], y = X[,2], z = Y)
XY <- data.frame(x1=X[,1],x2=X[,2],x3=X[,3],x4 = X[,4],y=Y)
mr <- lm(y ~ ., data = XY)
summary(mr)
mr <- lm(y ~ . + I(x1^2)  + I(x2^2)  + I(x3^2)  + I(x4^2), data = XY)
summary(mr)
pairs(XY)
which.max(XY[,5])
which.max(XY[,"Y"])
which.max(XY$y)
which.max(XY$Y)
which.max(XY$y)
XY[10,]
XY <- data.frame(x1=X[,1],x2=X[,2],x3=X[,3],x4 = X[,4],y=Y)
mr <- lm(y ~ ., data = XY)
summary(mr)
mr <- lm(y ~ . + I(x1^2)  + I(x2^2)  + I(x3^2)  + I(x4^2), data = XY)
summary(mr)
mr <- lm(y ~ .^2, data = XY)
summary(mr)
mr <- lm(y ~ x1 + x2  + I(x2^2) , data = XY)
summary(mr)
xg <- seq(0,1,0.1)
xpred <-  expand.grid(x1=xg,x2=xg)
predmr <- predict(mr,xpred)
plot3d(x = X[,1], y = X[,2], z = Y)
surface3d(xg,xg,matrix(predmr,length(xg)),col="wheat",alpha=0.5)
?km
library(DiceKriging)
?km
?simulate.km
?simulate
example(simulate)
covtype <- c("exp", "matern3_2", "matern5_2", "gauss")
d <- 1
n <- 500
x <- seq(from=0, to=3, length=n)
par(mfrow=c(1,2))
plot(x, rep(0,n), type="l", ylim=c(0,1), xlab="distance", ylab="covariance")
param <- 1
sigma2 <- 1
for (i in 1:length(covtype)) {
covStruct <- covStruct.create(covtype=covtype[i], d=d, known.covparam="All",
var.names="x", coef.cov=param, coef.var=sigma2)
y <- covMat1Mat2(covStruct, X1=as.matrix(x), X2=as.matrix(0))
lines(x, y, col=i, lty=i)
}
legend(x=1.3, y=1, legend=covtype, col=1:length(covtype),
lty=1:length(covtype), cex=0.8)
plot(x, rep(0,n), type="l", ylim=c(-2.2, 2.2), xlab="input, x",
ylab="output, f(x)")
for (i in 1:length(covtype)) {
model <- km(~1, design=data.frame(x=x), response=rep(0,n), covtype=covtype[i],
coef.trend=0, coef.cov=param, coef.var=sigma2, nugget=1e-4)
y <- simulate(model)
lines(x, y, col=i, lty=i)
}
par(mfrow=c(1,1))
n <- 200
x <- seq(from=0, to=1, length=n)
covtype <- "matern3_2"
coef.cov <- c(theta <- 0.3/sqrt(3))
sigma <- 1.5
trend <- c(intercept <- -1, beta1 <- 2, beta2 <- 3)
nugget <- 0   # may be sometimes a little more than zero in some cases,
# due to numerical instabilities
formula <- ~x+I(x^2)    # quadratic trend (beware to the usual I operator)
ytrend <- intercept + beta1*x + beta2*x^2
plot(x, ytrend, type="l", col="black", ylab="y", lty="dashed",
ylim=c(min(ytrend)-2*sigma, max(ytrend) + 2*sigma))
model <- km(formula, design=data.frame(x=x), response=rep(0,n),
covtype=covtype, coef.trend=trend, coef.cov=coef.cov,
coef.var=sigma^2, nugget=nugget)
y <- simulate(model, nsim=5, newdata=NULL)
for (i in 1:5) {
lines(x, y[i,], col=i)
}
par(mfrow=c(1,1))
n <- 200
x <- seq(from=0, to=1, length=n)
covtype <- "matern3_2"
coef.cov <- c(theta <- 0.3/sqrt(3))
sigma <- 1.5
trend <- c(intercept <- -1, beta1 <- 2, beta2 <- 3)
nugget <- 0   # may be sometimes a little more than zero in some cases,
# due to numerical instabilities
formula <- ~x+I(x^2)    # quadratic trend (beware to the usual I operator)
ytrend <- intercept + beta1*x + beta2*x^2
plot(x, ytrend, type="l", col="black", ylab="y", lty="dashed",
ylim=c(min(ytrend)-2*sigma, max(ytrend) + 2*sigma))
model <- km(formula, design=data.frame(x=x), response=rep(0,n),
covtype=covtype, coef.trend=trend, coef.cov=coef.cov,
coef.var=sigma^2, nugget=nugget)
y <- simulate(model, nsim=5, newdata=NULL)
for (i in 1:5) {
lines(x, y[i,], col=i)
}
n <- 200
x <- seq(from=0, to=1, length=n)
covtype <- "matern3_2"
coef.cov <- c(theta <- 0.1/sqrt(3))
sigma <- 1.5
trend <- c(intercept <- -1, beta1 <- 2, beta2 <- 3)
nugget <- 0   # may be sometimes a little more than zero in some cases,
# due to numerical instabilities
formula <- ~x+I(x^2)    # quadratic trend (beware to the usual I operator)
ytrend <- intercept + beta1*x + beta2*x^2
plot(x, ytrend, type="l", col="black", ylab="y", lty="dashed",
ylim=c(min(ytrend)-2*sigma, max(ytrend) + 2*sigma))
model <- km(formula, design=data.frame(x=x), response=rep(0,n),
covtype=covtype, coef.trend=trend, coef.cov=coef.cov,
coef.var=sigma^2, nugget=nugget)
y <- simulate(model, nsim=5, newdata=NULL)
for (i in 1:5) {
lines(x, y[i,], col=i)
}
n <- 200
x <- seq(from=0, to=1, length=n)
covtype <- "matern3_2"
coef.cov <- c(theta <- 0.3/sqrt(3))
sigma <- 1.5
trend <- c(intercept <- -1, beta1 <- 2, beta2 <- 3)
nugget <- 0   # may be sometimes a little more than zero in some cases,
# due to numerical instabilities
formula <- ~x+I(x^2)    # quadratic trend (beware to the usual I operator)
ytrend <- intercept + beta1*x + beta2*x^2
plot(x, ytrend, type="l", col="black", ylab="y", lty="dashed",
ylim=c(min(ytrend)-2*sigma, max(ytrend) + 2*sigma))
model <- km(formula, design=data.frame(x=x), response=rep(0,n),
covtype=covtype, coef.trend=trend, coef.cov=coef.cov,
coef.var=sigma^2, nugget=nugget)
y <- simulate(model, nsim=5, newdata=NULL)
for (i in 1:5) {
lines(x, y[i,], col=i)
}
n <- 200
x <- seq(from=0, to=1, length=n)
covtype <- "matern3_2"
coef.cov <- c(theta <- 0.3/sqrt(3))
sigma <- 1.5
trend <- c(intercept <- -1, beta1 <- 2, beta2 <- 3)
nugget <- 0   # may be sometimes a little more than zero in some cases,
# due to numerical instabilities
formula <- ~x+I(x^2)    # quadratic trend (beware to the usual I operator)
ytrend <- intercept + beta1*x + beta2*x^2
plot(x, ytrend, type="l", col="black", ylab="y", lty="dashed",
ylim=c(min(ytrend)-2*sigma, max(ytrend) + 2*sigma))
model <- km(formula, design=data.frame(x=x), response=rep(0,n),
covtype="exp", coef.trend=trend, coef.cov=coef.cov,
coef.var=sigma^2, nugget=nugget)
y <- simulate(model, nsim=5, newdata=NULL)
for (i in 1:5) {
lines(x, y[i,], col=i)
}
n <- 200
x <- seq(from=0, to=1, length=n)
covtype <- "matern3_2"
coef.cov <- c(theta <- 0.3/sqrt(3))
sigma <- 1.5
trend <- c(intercept <- -1, beta1 <- 2, beta2 <- 3)
nugget <- 0   # may be sometimes a little more than zero in some cases,
# due to numerical instabilities
formula <- ~x+I(x^2)    # quadratic trend (beware to the usual I operator)
ytrend <- intercept + beta1*x + beta2*x^2
plot(x, ytrend, type="l", col="black", ylab="y", lty="dashed",
ylim=c(min(ytrend)-2*sigma, max(ytrend) + 2*sigma))
model <- km(formula, design=data.frame(x=x), response=rep(0,n),
covtype="gauss", coef.trend=trend, coef.cov=coef.cov,
coef.var=sigma^2, nugget=nugget)
y <- simulate(model, nsim=5, newdata=NULL)
for (i in 1:5) {
lines(x, y[i,], col=i)
}
n <- 200
x <- seq(from=0, to=1, length=n)
covtype <- "matern3_2"
coef.cov <- c(theta <- 0.3/sqrt(3))
sigma <- 1.5
trend <- c(intercept <- -1, beta1 <- 2, beta2 <- 3)
nugget <- 0   # may be sometimes a little more than zero in some cases,
# due to numerical instabilities
formula <- ~x+I(x^2)    # quadratic trend (beware to the usual I operator)
ytrend <- intercept + beta1*x + beta2*x^2
plot(x, ytrend, type="l", col="black", ylab="y", lty="dashed",
ylim=c(min(ytrend)-2*sigma, max(ytrend) + 2*sigma))
model <- km(formula, design=data.frame(x=x), response=rep(0,n),
covtype="gauss", coef.trend=trend, coef.cov=coef.cov,
coef.var=sigma^2, nugget=nugget, nugget.sim=1e-5)
y <- simulate(model, nsim=5, newdata=NULL)
for (i in 1:5) {
lines(x, y[i,], col=i)
}
n <- 200
x <- seq(from=0, to=1, length=n)
covtype <- "matern3_2"
coef.cov <- c(theta <- 0.3/sqrt(3))
sigma <- 1.5
trend <- c(intercept <- -1, beta1 <- 2, beta2 <- 3)
nugget <- 0   # may be sometimes a little more than zero in some cases,
# due to numerical instabilities
formula <- ~x+I(x^2)    # quadratic trend (beware to the usual I operator)
ytrend <- intercept + beta1*x + beta2*x^2
plot(x, ytrend, type="l", col="black", ylab="y", lty="dashed",
ylim=c(min(ytrend)-2*sigma, max(ytrend) + 2*sigma))
model <- km(formula, design=data.frame(x=x), response=rep(0,n),
covtype="gauss", coef.trend=trend, coef.cov=coef.cov,
coef.var=sigma^2, nugget=nugget)
y <- simulate(model, nsim=5, newdata=NULL, nugget.sim=1e-5)
for (i in 1:5) {
lines(x, y[i,], col=i)
}
n <- 200
x <- seq(from=0, to=1, length=n)
covtype <- "matern3_2"
coef.cov <- c(theta <- 0.3/sqrt(3))
sigma <- 1.5
trend <- c(intercept <- -1, beta1 <- 2, beta2 <- 3)
nugget <- 1e-6   # may be sometimes a little more than zero in some cases,
# due to numerical instabilities
formula <- ~x+I(x^2)    # quadratic trend (beware to the usual I operator)
ytrend <- intercept + beta1*x + beta2*x^2
plot(x, ytrend, type="l", col="black", ylab="y", lty="dashed",
ylim=c(min(ytrend)-2*sigma, max(ytrend) + 2*sigma))
model <- km(formula, design=data.frame(x=x), response=rep(0,n),
covtype="gauss", coef.trend=trend, coef.cov=coef.cov,
coef.var=sigma^2, nugget=nugget)
y <- simulate(model, nsim=5, newdata=NULL)
for (i in 1:5) {
lines(x, y[i,], col=i)
}
library(DiceKriging)
m0<- km(~1+axe+butee, design=X, response=Y)
print(m0)   # display model
plot(m0)    # visual model validation
m0<- km(~1, design=X, response=Y)
print(m0)   # display model
library(DiceView)
sectionview(m0, center = c(0, 1, 0.5, 0.5))
print(m0)   # affichage
plot(m0)    # validation
library(DiceView)
sectionview(m0, center = c(0, 1, 0.5, 0.5))
sectionview3d(m0, center = c(0, 1, 0.5, 0.5))
sectionview(m0, center = X[which.max(Y),])
library(DiceOptim)
runExperimentMin <- function(x){
-runExperiment(x)[1]
}
Y <- apply(X, 1, runExperimentMin)
m0<- km(~1, design=X, response=Y)
oEGO <- max_EI(model = m0, lower = rep(0, 4), upper = rep(1, 4))
newX <- oEGO$par
newy <- catapultRmin(newX)
newX <- oEGO$par
newy <- runExperimentMin(newX)
newX <- oEGO$par
newy <- runExperimentMin(newX)
cat("Expected improvement was :", round(oEGO$value,2))
cat("Actual improvement is", round(min(Y) - newy,2)," (positive value means the new point is better)")
m <- update(m0, newX, newy)
m0
m
plot(m)
plot(m0)
bestPoint <- which.min(oEGO$value)
cat("longest shot observed:",round(oEGO$value[bestPoint],2))
cat("corresponding input values:",round(oEGO$par[bestPoint,],2))
oEGO$values
oEGO$value
str(m)
m$y
m$response
m$Y
m@y
m0@y
min(m@y)
min(m0@y)
cat("longest shot observed:",round(-min@y,2))
cat("longest shot observed:",round(-min(m@y),2))
cat("corresponding input values:",round(oEGO$par[bestPoint,],2))
visualizeEGO <- function(initDesign, initValues, EGOpoints, EGOvalues){
bestIndex <- which.min(EGOvalues)
y <- c(initValues, EGOvalues, EGOvalues[bestIndex])
X <- rbind(initDesign, EGOpoints, EGOpoints[bestIndex, ])
ninit <- nrow(initDesign)
nsteps <- nrow(EGOpoints)
pairs(cbind(y, X),
col = c(rep("black", ninit), rep("blue", nsteps), "red"),
pch = c(rep(1, ninit + nsteps), 19))
}
visualizeEGO(initDesign = X, initValues = Y,
EGOpoints = oEGO$par, EGOvalues = oEGO$val)
visualizeEGO(initDesign = X, initValues = -Y,
EGOpoints = oEGO$par, EGOvalues = oEGO$val)
plot(c(Y,oEGO$value),main="convergence",xlab="evaluation number",ylab="Y values")
lines(rep(length(Y),2),range(Y,oEGO$value),lty=2,col="gray")
lines(length(Y)+0:length(oEGO$value),c(min(Y),cummin(oEGO$value)),col="red",lwd=2)
sectionview(oEGO$lastmodel, center = oEGO$par[bestPoint, ])
oEGO$lastmodel
str(oEGO)
oEGO <- EGO.nsteps(model = m0, fun = runExperimentMin, nsteps = 20,
lower = rep(0, 4), upper = rep(1, 4))
bestPoint <- which.min(oEGO$value)
cat("longest shot observed:",-round(oEGO$value[bestPoint],2),
"\ncorresponding input values:",round(oEGO$par[bestPoint,],2))
bestPoint <- which.min(oEGO$value)
cat("longest shot observed:", -round(oEGO$value[bestPoint],2))
cat("corresponding input values:", round(oEGO$par[bestPoint,],2))
visualizeEGO <- function(initDesign, initValues, EGOpoints, EGOvalues){
bestIndex <- which.min(EGOvalues)
y <- c(initValues, EGOvalues, EGOvalues[bestIndex])
X <- rbind(initDesign, EGOpoints, EGOpoints[bestIndex, ])
ninit <- nrow(initDesign)
nsteps <- nrow(EGOpoints)
pairs(cbind(y, X),
col = c(rep("black", ninit), rep("blue", nsteps), "red"),
pch = c(rep(1, ninit + nsteps), 19))
}
visualizeEGO(initDesign = X, initValues = Y,
EGOpoints = oEGO$par, EGOvalues = oEGO$val)
plot(c(Y,oEGO$value),main="convergence",xlab="evaluation number",ylab="Y values")
lines(rep(length(Y),2),range(Y,oEGO$value),lty=2,col="gray")
lines(length(Y)+0:length(oEGO$value),c(min(Y),cummin(oEGO$value)),col="red",lwd=2)
sectionview(oEGO$lastmodel, center = oEGO$par[bestPoint, ])
rm(list=ls())
source('/Olivier/Formations/2016_06_FontenayAuxRoses/catapult/TPsolutions27juin.R')
source('/Olivier/Formations/2016_06_FontenayAuxRoses/catapult/TPsolutions27juin.R')
min(Y)
